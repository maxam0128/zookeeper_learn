# A FIRST LOOK INTO ZGC

## 减少停顿时间的几种途径

- 在GC压缩的时候可以使用多线程(并行压缩)
- 压缩工作可以分为多个交叉的阶段(增量压缩)
- 并发压缩(不停止应用线程或停止一小段时间)
- 只做简单的GC不处理压缩

ZGC 使用并发压缩，下面介绍一下ZGC 是如何实现的(它并不是一个简单的特性)：

- 拷贝对象到另外的内存地址，与此同时其他的线程可能正在读写这个旧对象
- 如果拷贝成功，在堆上仍然有可能有很多对象引用的是旧对象的地址，这时就需要将那些旧地址更新为新地址

## GC 屏障

理解ZGC并发压缩的关键点就是 load barrier (在GC 的场景下通常称为读屏障)。对于读屏障不熟悉的读者，下面给出个简介，详细的参考[load-barrier](https://dinfuehr.github.io/blog/a-first-look-into-zgc/#load-barrier).
如果在GC时有读屏障，当从堆上读取引用时需要做一些额外的动作。

例如java中经常对有这种代码 obj.field。对于像 obj.field = value 这样的操作GC时需要一个写屏障(write/store-barrier)。对于堆的读/写这两种操作都是特殊的操作。
对于CPU来说，GC屏障和 内存屏障是不同的，这两种名字可能容易混淆。但是对于堆的读/写是非常常见的操作，所以GC 屏障必须有很高的效率。这意味着在通用的场景下只会合成少数的指令。
读屏障一般要比写屏障高一个数量级(依赖于具体的应用)，所以读屏障更容易影响性能。大于大多数的GC是没有读屏障的只有写屏障。但是ZGC需要的是读屏障而没有写屏障。
对于并发压缩的场景目前还没有不使用读屏障的解决方案。还有另外一个要考虑的因素：即使GC需要更多类型的屏障，但是当他们再读/写堆时，也许只需要一种类型。

## 指针标记

ZGC 在堆引用上存储了额外的信息，在x64机器上引用类型为64-bit 宽(ZGC 不支持指针压缩)。ZGC 使用了64位中的48位来表示虚拟内存地址。但实际只用了47位，因为47位的值决定了48-63位的值。
ZGC 会将对象的实际地址保存在前42位上。42位地址理论上就限制了ZGC 只能有4TB的堆。其余5位就是标志位：finalizable, remapped, marked1 and marked0 (一个保留位，以便将来使用).
下面是ZGC 的占用的位：

```
+-------------------+-+----+-----------------------------------------------+
+-------------------+-+4flag+--------------42 位地址-------------------------+
 6                 4 4 4  4 4                                             0
 3                 7 6 5  2 1                                             0
+-------------------+-+----+-----------------------------------------------+
|00000000 00000000 0|0|1111|11 11111111 11111111 11111111 11111111 11111111|
+-------------------+-+----+-----------------------------------------------+
|                   | |    |
|                   | |    * 41-0 Object Offset (42-bits, 4TB address space)
|                   | |
|                   | * 45-42 Metadata Bits (4-bits)  0001 = Marked0
|                   |                                 0010 = Marked1
|                   |                                 0100 = Remapped
|                   |                                 1000 = Finalizable
|                   |
|                   * 46-46 Unused (1-bit, always zero)
|
* 63-47 Fixed (17-bits, always zero)
```
有了堆上的元引用信息会使解除引用代价比较高。因为需要对地址进行掩码解析后才能获得真实地址（没有元数据信息的）。ZGC 用来一个巧妙的方法来避免：
当需要从内存中读取时会在 marked0, marked1 or remapped中设置一个标志位。当在 偏移x 分配一个页是，ZGC会将这个页面映射到3个不同的地址上：
ZGC会将这个页面映射到[3个不同](http://hg.openjdk.java.net/zgc/zgc/file/59c07aef65ac/src/hotspot/os_cpu/linux_x86/zPhysicalMemoryBacking_linux_x86.cpp#l212")的地址上

- for marked0: (0b0001 << 42) | x
- for marked1: (0b0010 << 42) | x
- for remapped: (0b0100 << 42) | x 

因此， ZGC仅保留了从4TB开始的，总计16TB的地址空间（实际上这些内存并没有被全部使用）。ZGC源码中有一个很好的图表可以说明这一点：

```
  +--------------------------------+ 0x0000140000000000 (20TB)
  |         Remapped View          |
  +--------------------------------+ 0x0000100000000000 (16TB)
  |     (Reserved, but unused)     |
  +--------------------------------+ 0x00000c0000000000 (12TB)
  |         Marked1 View           |
  +--------------------------------+ 0x0000080000000000 (8TB)
  |         Marked0 View           |
  +--------------------------------+ 0x0000040000000000 (4TB)
```
在任意的时间点，这3个视图中仅有一个处于使用状态。因此，调试未使用视图，可以取消映射以更好的验证正确性。

## 页面、物理内存与虚拟内存

Shenandoah收集器将堆区划分成很多大小相等的区域（region）。
除非是一个区域放不下的大对象，通常情况一个对象下并不会横跨多个区域。这些跨域的大对象需要分配在多个连续的区域中。我十分喜欢这种简单粗暴的分配方式。

在这方面，ZGC和Shenandoah十分相似。在ZGC的概念中，用“页面”这个名称来代替“区域”。
与Shenandoah主要的不同点在于：ZGC中的页面大小是不同的（但总是2MB的倍数）。ZGC总共有3种不同类型的页面：小页（2MB）、中等页（32MB）和大页（2MB的多倍）。
小对象（不超过256KB）被分配到小页面中，中等对象（不超过4MB）被分配到中等页面。超过4MB大小的对象直接分配到大页，并且一个大页只会恰好存一个对象。
也许会令人疑惑，大页面可能会比中等页面小（例如一个只有6MB的大页面）。

区分物理内存和虚拟内存，是ZGC另一个非常好的特性。
这背后的思想在于：当物理内存紧缺的时候，仍然可能存在大量可用虚拟内存（ZGC中总是4TB）。
物理内存最大可以扩展到堆的最大值（用-Xmx参数设置），所以通常远小于虚拟内存的4TB大小。
在ZGC中分配一个特定大小的页面，意味着要同时分配物理内存和虚拟内存。虚拟内存必须是连续的，物理内存无此要求。
所以，难道这不是一个很令人兴奋的特性吗？

分配一大片连续的虚拟内存是一件十分容易的事情，因为虚拟内存通常非常充足。
很容易想象这样一种场景：物理内存中有3个大小为2MB的自由页面，但是现在有一个大对象需要一个连续的6MB空间。
这种情况下，物理内存是足够的，但是不幸的是，这些物理内存是不连续的。
ZGC可以将这些不连续的内存映射为单一连续的虚拟内存。如果没实现这个的话，我们就会遇到内存耗尽问题。

## 标记与重定位对象
一个收集过程通常被分为两个阶段：标记与重定位。（实际上不止这两个过程，可以阅读ZGC源码以获取更多细节）。

一个垃圾收集的过程，通常是从标记阶段开始，在这个阶段的最后，我们会知道哪些对象是垃圾哪些对象需要存活下来。
ZGC将这些信息存储在每个页面上称之为“存活地图”的地方。
存活地图是一个位图，存储着一个给定索引的对象是否是强可达或最终可达（对于一个对象来说，具有finalize方法）的信息。

在标记阶段，应用线程上的读屏障会将未标记的引用放入本地线程的标记缓冲区中。
只要缓冲区满了，垃圾收集线程就会接管这个缓冲区，然后递归遍历缓冲区中所有的可达对象。
应用程序线程仅仅是将引用放入缓冲区，垃圾回收线程负责遍历对象和更新存活地图。

标记之后，ZGC需要将重定位集中所有存活的对象重定位。
所谓“重定位集”，就是一系列在标记后需要被清空的页面的集合（例如那些垃圾最多的页面）。
一个对象，要么被垃圾回收线程要么被应用线程重定位（都是通过读屏障）。
在重定位集中的每个页面，ZGC都分配了一个转发表，转发表一般是一个哈希映射表，里面存储着一个已经被重定位的对象的地址（如果这个对象已经被重定位）。

ZGC的优势在于，仅需要对处于重定位集中的页面中的转发指针分配空间。与之对应的是Shenandoah在每个对象内都存储了转发指针，这会带来一些内存开销。

垃圾回收线程会遍历重定位集中尚未重定位的所有存活的对象。应用线程和垃圾回收线程可能同时试图将同一个对象重定位，这种情况下，第一个执行重定位动作的线程获胜。
ZGC使用一个原子的CAS操作来决定哪个线程胜出。

当没有进行标记的时候，读屏障会对所有从堆中读取到的引用进行重定位或重映射。
这确保了突变因子读到的每个最新引用，都已经指向了对象最新的拷贝。重映射指得是在转发表中寻找一个新的对象地址。

当垃圾回收线程完成遍历重定位集的时候，重定位阶段就结束了。
尽管这时所有对象都已经被重定位，但是通常仍然还有一些引用指向重定位集中，因此需要重映射到它们的新地址。
这些引用将在下一轮的标记周期中，通过捕获读屏障来修复。这意味着在标记阶段还需要检查转发表来将对象重映射（不是重定位-这个时候所有对象都确保已经被重定位）到新地址。

这也解释了为什么一个对象引用中mark位有2个bit（marked0和marked1）：标记阶段，两个bit位被轮流使用。
重定位阶段过后，仍然可能有引用没有被重映射，同时mark位仍然是上一个标记阶段设置的。在新的标记阶段，如果要使用同一个mark位，读屏障会检测到这个引用已经被标记。

## 加载屏障

当从堆中读取一个引用时，ZGC需要一个加载屏障（也被称为读屏障）。当Java程序访问一个对象类型的域的时候，同样需要插入一个类似于obj.field的加载屏障。
访问类似于obj.anInt或obj.anDouble这样基本数据类型的域的时候，不需要加载屏障。对于类似obj.field=someValue这样的写操作，ZGC不需要写屏障。

取决于当前垃圾收集器所处的阶段（存储在全局变量ZGlobalPhase中），如果一个对象引用没有被标记或重映射，那么屏障要么标记要么重定位这个对象引用。

一个对象引用是好（已经被标记/重定位/重映射）还是坏（还需要进行一个额外），取决于全局变量ZAddressGoodMask和ZAddressBadMask中存储的掩码。这些变量只会在标记和重定位的开始阶段才改变，并且是同时改变。下图展示了这些掩码的可能状态。



关于屏障的汇编代码可以在x64机器的MacroAssembler模块查看，本文仅仅展示些读屏障伪汇编代码：

mov rax, [r10 + some_field_offset]
test rax, [address of ZAddressBadMask]
jnz load_barrier_mark_or_relocate

# otherwise reference in rax is considered good

第一条汇编指令表示从堆中读取一个引用：r10存储对象的引用，some_field_offset是一些偏移常数。加载的引用被存储在rax寄存器中。之后这个引用与坏掩码逐位与操作。此处不需要同步操作，因为ZAddressBadMask只有在stop the word的时候才会获取更新值。如果结果非0，则需要执行这个屏障。根据垃圾收集器所处阶段的不同，屏障会决定对这个对象进行标记还是重定位。之后，需要更新r10+some_field_offset中的引用为好的引用。这样，后面从这个域加载的时候就会返回一个好的引用，因此这是很有必要的。因为我们可能需要更新引用地址，所以要使用r10和rax两个寄存器来表示已加载的引用和对象地址。好的引用也需要存储在rax寄存器中，这样当我们想加载这个引用时，操作可以顺利的执行下去。

因为每一个引用都需要被标记或重定位，所以在开始标记或重定位的阶段，吞吐量似乎会下降。但是当多数的引用被修复后，这种情况很快就会好转。

Stop-the-World 阶段
ZGC并没有完全解决stop-the-world问题。在开始标记、结束标记以及开始重定位这3个节点，应用线程仍然会被暂停。但是这个暂停是非常短暂的，通常是仅仅几毫秒。

在开始标记的阶段，ZGC遍历所有线程栈来标记应用的根集。根集是遍历对象图的起点对象应用的集合。这些对象引用通常是本地变量或者全局变量，但是也可能是虚拟机内部数据结构（例如Java本地接口句柄）。

在标记结束阶段，暂停也是必要的。因为这个节点，垃圾收集器需要清空和移动所有线程本地标记缓冲区。因为垃圾收集器可能会搜索一个比较大的未标记的子图，因此这个阶段可能会稍长一些。ZGC通过在标记结束阶段停止1毫秒，然后回到并发标记阶段，直到整个图被遍历，然后再重新开始结束标记阶段，以避免停顿时间过长。

开始重定位这个阶段，还会再次停止应用程序。这个阶段与开始标记阶段很相似，不同的是这个阶段重定位位于根集合中的对象。

总结：
希望本文能给大家带来一个关于ZGC的简要介绍。本文无法面面俱到的描述ZGC，如果读者想获得更多信息，ZGC是开源的，所以可以探究它的全部实现细节。

