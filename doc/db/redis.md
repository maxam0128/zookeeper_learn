# Redis

## 数据结构

- String
- list
- set
- map
- sorted-set

## String 

在Redis内部，作为字符串承载的String 型value内部是以int、SDS(simple dynamic string)作为存储结构的。
int 存储整型数据，sds存放字节/字符串和浮点型数据。

## List

使用双端链表实现的。Redis中存储了列表的head，tail和长度，所以操作首节点或尾节点或者获取list长度是的时间复杂度为O(1)。
List存储的是一个有序集合。


## Set

底层就是通过字典实现的

## Hash

## ZSet
 
ZSet 底层是包含了一个字典和skipList实现的，通过score





## 字典

### hash 算法

MurmurHash算法 

### 冲突解决

使用链表的方式来解决冲突。
### rehash

字典表增长/减少 到一定程度时会进行扩容/缩容，这个时候需要进行rehash。
### 渐进式 rehash

- 1、为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个hash表。
- 2、在字典中维持一个索引计数器变量rehashindex，并将它置为0，表示rehash正式开始
- 3、在rehash期间，每次对字典执行 添加、删除、修改或查找动作时，程序除了执行指定的操作还会将ht[0]hash表在rehashindex索引上的所有键值对rehash到ht[1]上，当rehash完成后，程序会将rehashindex值增一。


在渐进式rehash期间，字典会同时使用ht[0]和ht[1]，所以在渐进式rehash期间，字典的删除、更新、查找会在两个hash表上同时进行。另外所有添加操作会一律被保存在ht[1]里面，保证ht[0]只减不增。


## 跳表

跳表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问的目的。

Redis 使用跳表作为有序集合底层实现之一，如果一个有序集合包含的元素数量比较多或有序集合中元素的成员是比较长的字符串时，Redis就会使用跳表作为有序集合键的底层实现。



## 持久化

### RDB

RDB 持久化可以手动触发也可以通过配置周期执行。改功能可以将某个时间点的上的数据库状态保存在一个RDB文件中。


#### RDB 文件创建与载入

- 1、SAVE

SAVE 命令会阻塞Redis服务器进程，知道RDB文件创建完成，在服务器阻塞期间不处理任何命令的请求。

- 2、BGSAVE

和SAVE 命令不同的是，BGSAVE会派生出一个子进程，然后由子进程生成RDB文件，父进程继续处理命令请求。
在BGSAVE命令执行期间，客户端发送的SAVE/BGSAVE命令会被服务器拒绝。

服务器在启动时会自动检查RDB文件是否存在，如果存在就自动载入RDB文件，在载入RDB文件时，服务器会一直处于阻塞状态，直到RDB文件载入完毕。

注：由于AOF文件更新的频率会比RDB高，所以：

  如果服务器开启AOF持久化功能，那么服务器会优先使用AOF文件来还原数据。
  只有在AOF持久化功能处于关闭的情况下，服务器才会使用RDB还还原数据。
 
 
#### 自动间隔性保存

redis 也允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。

如：save 900 1 在900s之内对服务器执行了至少一次修改
  

### AOF




